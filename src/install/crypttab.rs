//! Crypttab generation for LUKS containers

use crate::config::DeploymentConfig;
use crate::configure::encryption::{get_luks_uuid, LuksContainer};
use crate::configure::keyfiles::{keyfile_path, VolumeKeyfile};
use crate::disk::detection::partition_path;
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use tracing::info;

/// Generate /etc/crypttab for the installed system (legacy single-volume)
///
/// If `boot_luks_partition` is Some, an additional entry for the encrypted
/// /boot partition (LUKS1) will be included.
#[allow(dead_code)]
pub fn generate_crypttab(
    cmd: &CommandRunner,
    config: &DeploymentConfig,
    device: &str,
    luks_partition: u32,
    boot_luks_partition: Option<u32>,
    install_root: &str,
) -> Result<()> {
    info!("Generating /etc/crypttab");

    let luks_device = partition_path(device, luks_partition);

    // Extract the mapping name without "Crypt-" prefix for crypttab
    // crypttab uses the base name (e.g., "Root"), the hook adds "Crypt-" prefix
    let mapper_name = config
        .disk
        .luks_mapper_name
        .trim_start_matches("Crypt-")
        .to_string();

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate /etc/crypttab:");
        println!("    {} UUID=<LUKS_UUID> none luks,discard", mapper_name);
        if boot_luks_partition.is_some() {
            let boot_mapper = config
                .disk
                .luks_boot_mapper_name
                .trim_start_matches("Crypt-");
            println!("    {} UUID=<BOOT_LUKS_UUID> none luks,discard", boot_mapper);
        }
        return Ok(());
    }

    let uuid = get_luks_uuid(&luks_device)?;

    // Determine keyfile path
    let keyfile = config
        .disk
        .keyfile_path
        .as_deref()
        .unwrap_or("none");

    let mut content = format!(
        r#"# /etc/crypttab - Generated by Deploytix
# <name>    <device>              <keyfile>    <options>
{name}    UUID={uuid}    {keyfile}    luks,discard
"#,
        name = mapper_name,
        uuid = uuid,
        keyfile = keyfile,
    );

    // Add boot LUKS1 entry if boot encryption is enabled
    if let Some(boot_part_num) = boot_luks_partition {
        let boot_device = partition_path(device, boot_part_num);
        let boot_uuid = get_luks_uuid(&boot_device)?;
        let boot_mapper = config
            .disk
            .luks_boot_mapper_name
            .trim_start_matches("Crypt-")
            .to_string();

        content.push_str(&format!(
            "{name}    UUID={uuid}    {keyfile}    luks,discard\n",
            name = boot_mapper,
            uuid = boot_uuid,
            keyfile = keyfile,
        ));
    }

    let crypttab_path = format!("{}/etc/crypttab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&crypttab_path, content)?;

    info!("Crypttab written to {}", crypttab_path);
    Ok(())
}

/// Generate /etc/crypttab for multi-volume encrypted system
///
/// Creates entries for ROOT, USR, VAR, and HOME with keyfile paths
/// for automatic unlocking during initramfs.
pub fn generate_crypttab_multi_volume(
    cmd: &CommandRunner,
    containers: &[LuksContainer],
    keyfiles: &[VolumeKeyfile],
    install_root: &str,
) -> Result<()> {
    info!("Generating /etc/crypttab for {} encrypted volumes", containers.len());

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate /etc/crypttab:");
        for container in containers {
            let volume_name = container.mapper_name.trim_start_matches("Crypt-");
            let kf_path = keyfile_path(volume_name);
            println!("    {} UUID=<LUKS_UUID> {} luks,discard", volume_name, kf_path);
        }
        return Ok(());
    }

    let mut content = String::from(
        "# /etc/crypttab - Generated by Deploytix\n\
         # Multi-volume encrypted system with keyfile-based automatic unlocking\n\
         #\n\
         # <name>    <device>              <keyfile>                              <options>\n"
    );

    for container in containers {
        let uuid = get_luks_uuid(&container.device)?;

        // Extract volume name from mapper name (e.g., "Crypt-Root" -> "Root")
        let volume_name = container.mapper_name
            .trim_start_matches("Crypt-")
            .to_string();

        // Find matching keyfile
        let kf_path = keyfiles
            .iter()
            .find(|k| k.volume_name == volume_name)
            .map(|k| k.keyfile_path.clone())
            .unwrap_or_else(|| keyfile_path(&volume_name));

        content.push_str(&format!(
            "{name}    UUID={uuid}    {keyfile}    luks,discard\n",
            name = volume_name,
            uuid = uuid,
            keyfile = kf_path,
        ));
    }

    let crypttab_path = format!("{}/etc/crypttab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&crypttab_path, &content)?;

    info!("Crypttab written to {} with {} entries", crypttab_path, containers.len());
    Ok(())
}
