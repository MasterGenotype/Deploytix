//! Fstab generation

use crate::config::{Filesystem, SwapType};
use crate::configure::encryption::LuksContainer;
use crate::configure::swap::{swap_file_fstab_entry, SWAP_FILE_PATH};
use crate::disk::detection::partition_path;
use crate::disk::formatting::get_partition_uuid;
use crate::disk::layouts::{ComputedLayout, SubvolumeDef};
use crate::disk::lvm::{lv_path, ThinVolumeDef};
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use std::io::Write;
use tracing::info;

/// Generate fstab using UUIDs
/// Handles both regular partitions and btrfs subvolume layouts
pub fn generate_fstab(
    cmd: &CommandRunner,
    device: &str,
    layout: &ComputedLayout,
    filesystem: &Filesystem,
    install_root: &str,
) -> Result<()> {
    // Check if this layout uses subvolumes
    if layout.uses_subvolumes() {
        return generate_fstab_with_subvolumes(cmd, device, layout, install_root);
    }

    info!(
        "Generating /etc/fstab for {} partitions on {}",
        layout.partitions.len(),
        device
    );

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with entries:");
        for part in &layout.partitions {
            if let Some(ref mp) = part.mount_point {
                println!("    UUID=<uuid> {} <fstype> defaults 0 1", mp);
            } else if part.is_swap {
                println!("    UUID=<uuid> none swap defaults 0 0");
            }
        }
        return Ok(());
    }

    let mut fstab_content = String::new();
    fstab_content.push_str("# /etc/fstab: static file system information.\n");
    fstab_content.push_str("# Generated by Deploytix\n");
    fstab_content.push_str("#\n");
    fstab_content.push_str("# <file system> <mount point> <type> <options> <dump> <pass>\n\n");

    for part in &layout.partitions {
        let part_path = partition_path(device, part.number);
        let uuid = get_partition_uuid(&part_path)?;

        if part.is_swap {
            fstab_content.push_str(&format!("UUID={}\tnone\tswap\tdefaults\t0\t0\n", uuid));
        } else if let Some(ref mount_point) = part.mount_point {
            // Determine filesystem type and options based on partition role
            let (fstype, options, pass) = if part.is_efi {
                ("vfat", "defaults,noatime", 2)
            } else if part.is_boot_fs {
                // BOOT partition is always btrfs (format_boot always uses mkfs.btrfs)
                ("btrfs", "defaults,noatime", 2)
            } else {
                // Data partitions use the user-chosen filesystem
                let (fstype, options) = match filesystem {
                    Filesystem::Ext4 => ("ext4", "defaults,noatime"),
                    Filesystem::Btrfs => ("btrfs", "defaults,noatime,compress=zstd"),
                    Filesystem::Xfs => ("xfs", "defaults,noatime"),
                    Filesystem::F2fs => ("f2fs", "defaults,noatime"),
                };
                // btrfs and xfs do not use fsck (pass=0); ext4/f2fs use pass 1 for root, 2 for rest
                let pass = match filesystem {
                    Filesystem::Btrfs | Filesystem::Xfs => 0,
                    _ => {
                        if mount_point == "/" {
                            1
                        } else {
                            2
                        }
                    }
                };
                (fstype, options, pass)
            };

            fstab_content.push_str(&format!(
                "UUID={}\t{}\t{}\t{}\t0\t{}\n",
                uuid, mount_point, fstype, options, pass
            ));
        }
    }

    // Write fstab
    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    let mut file = fs::File::create(&fstab_path)?;
    file.write_all(fstab_content.as_bytes())?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Generate fstab for layouts using btrfs subvolumes
fn generate_fstab_with_subvolumes(
    cmd: &CommandRunner,
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    let subvolumes = layout.subvolumes.as_ref().unwrap();
    info!(
        "Generating /etc/fstab with {} btrfs subvolumes",
        subvolumes.len()
    );

    // Find the root partition (the one with btrfs subvolumes)
    let root_part = layout
        .partitions
        .iter()
        .find(|p| p.name == "ROOT")
        .ok_or_else(|| {
            crate::utils::error::DeploytixError::ConfigError(
                "No ROOT partition found for subvolume layout".to_string(),
            )
        })?;

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with btrfs subvolumes:");
        for sv in subvolumes {
            println!(
                "    UUID=<ROOT_UUID> {} btrfs subvol={},{} 0 {}",
                sv.mount_point,
                sv.name,
                sv.mount_options,
                if sv.mount_point == "/" { 1 } else { 0 }
            );
        }
        return Ok(());
    }

    let root_path = partition_path(device, root_part.number);
    let root_uuid = get_partition_uuid(&root_path)?;

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix - Btrfs subvolume layout\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n",
    );

    // Add subvolume entries
    for sv in subvolumes {
        let pass = if sv.mount_point == "/" { 1 } else { 0 };
        content.push_str(&format!(
            "UUID={}  {}  btrfs  subvol={},{}  0  {}\n",
            root_uuid, sv.mount_point, sv.name, sv.mount_options, pass,
        ));
    }

    // Add other partitions (EFI, swap, etc.)
    for part in &layout.partitions {
        if part.name == "ROOT" {
            continue; // Already handled via subvolumes
        }

        let part_path = partition_path(device, part.number);
        let uuid = get_partition_uuid(&part_path)?;

        if part.is_swap {
            content.push_str(&format!(
                "\n# Swap partition\nUUID={}  none  swap  defaults  0  0\n",
                uuid
            ));
        } else if part.is_efi {
            content.push_str(&format!(
                "\n# EFI System Partition\nUUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
                uuid
            ));
        } else if let Some(ref mount_point) = part.mount_point {
            content.push_str(&format!(
                "\nUUID={}  {}  btrfs  defaults,noatime  0  2\n",
                uuid, mount_point
            ));
        }
    }

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!(
        "Fstab written to {} with {} subvolume entries",
        fstab_path,
        subvolumes.len()
    );
    Ok(())
}

/// Use fstabgen to generate fstab (alternative method)
#[allow(dead_code)]
pub fn generate_fstab_with_fstabgen(cmd: &CommandRunner, install_root: &str) -> Result<()> {
    info!("Generating fstab using fstabgen");

    let output = cmd.run_output("fstabgen", &["-U", install_root])?;

    if let Some(content) = output {
        let fstab_path = format!("{}/etc/fstab", install_root);
        if !cmd.is_dry_run() {
            fs::create_dir_all(format!("{}/etc", install_root))?;
            fs::write(&fstab_path, content)?;
        }
    }

    Ok(())
}

/// Generate fstab for encrypted layout with btrfs subvolumes on LUKS (legacy helper)
#[allow(dead_code)]
pub fn generate_fstab_crypto_subvolume(
    cmd: &CommandRunner,
    mapped_device: &str,
    boot_device: &str,
    efi_device: &str,
    subvolumes: &[SubvolumeDef],
    install_root: &str,
) -> Result<()> {
    info!(
        "Generating /etc/fstab for {} encrypted btrfs subvolumes",
        subvolumes.len()
    );

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with btrfs subvolumes:");
        for sv in subvolumes {
            println!(
                "    UUID=<BTRFS_UUID> {} btrfs subvol={},... 0 {}",
                sv.mount_point,
                sv.name,
                if sv.mount_point == "/" { 1 } else { 0 }
            );
        }
        println!("    UUID=<BOOT_UUID> /boot btrfs defaults,noatime 0 2");
        println!("    UUID=<EFI_UUID> /boot/efi vfat umask=0077,defaults 0 2");
        return Ok(());
    }

    let btrfs_uuid = get_partition_uuid(mapped_device)?;
    let boot_uuid = get_partition_uuid(boot_device)?;
    let efi_uuid = get_partition_uuid(efi_device)?;

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n\
         # Encrypted btrfs root (mapped as /dev/mapper/Crypt-Root in initramfs)\n",
    );

    // Add subvolume entries
    for sv in subvolumes {
        let pass = if sv.mount_point == "/" { 1 } else { 0 };
        content.push_str(&format!(
            "UUID={}  {}  btrfs  subvol={},{}  0  {}\n",
            btrfs_uuid, sv.mount_point, sv.name, sv.mount_options, pass,
        ));
    }

    // Add boot partition entry
    content.push_str(&format!(
        "\n# Boot partition\n\
         UUID={}  /boot  btrfs  defaults,noatime  0  2\n",
        boot_uuid
    ));

    // Add EFI entry
    content.push_str(&format!(
        "\n# EFI System Partition\n\
         UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
        efi_uuid
    ));

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Generate fstab for multi-volume encrypted system
///
/// Creates entries for separate encrypted partitions (ROOT, USR, VAR, HOME)
/// mounted from /dev/mapper/Crypt-* devices.
pub fn generate_fstab_multi_volume(
    cmd: &CommandRunner,
    containers: &[LuksContainer],
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    info!(
        "Generating /etc/fstab for {} encrypted volumes",
        containers.len()
    );

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with encrypted volumes:");
        for container in containers {
            let mp = container.volume_name.to_lowercase();
            let mount_point = if mp == "root" {
                "/"
            } else {
                &format!("/{}", mp)
            };
            println!(
                "    {} {} btrfs defaults,noatime,compress=zstd 0 {}",
                container.mapped_path,
                mount_point,
                if mount_point == "/" { 1 } else { 2 }
            );
        }
        return Ok(());
    }

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix - Multi-volume encrypted system\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n",
    );

    // Add encrypted volume entries
    for container in containers {
        let mount_point = match container.volume_name.as_str() {
            "Root" => "/".to_string(),
            name => format!("/{}", name.to_lowercase()),
        };

        let pass = if mount_point == "/" { 1 } else { 2 };

        // Get UUID of the btrfs filesystem on the mapped device
        let fs_uuid = get_partition_uuid(&container.mapped_path)?;

        content.push_str(&format!(
            "# {} partition (LUKS encrypted)\n\
             UUID={}  {}  btrfs  defaults,noatime,compress=zstd  0  {}\n\n",
            container.volume_name, fs_uuid, mount_point, pass
        ));
    }

    // Add SWAP partition
    let swap_part = layout.partitions.iter().find(|p| p.is_swap);
    if let Some(swap) = swap_part {
        let swap_device = partition_path(device, swap.number);
        let swap_uuid = get_partition_uuid(&swap_device)?;
        content.push_str(&format!(
            "# Swap partition\n\
             UUID={}  none  swap  defaults  0  0\n\n",
            swap_uuid
        ));
    }

    // Add BOOT partition
    let boot_part = layout.partitions.iter().find(|p| p.is_boot_fs);
    if let Some(boot) = boot_part {
        let boot_device = partition_path(device, boot.number);
        let boot_uuid = get_partition_uuid(&boot_device)?;
        content.push_str(&format!(
            "# Boot partition\n\
             UUID={}  /boot  btrfs  defaults,noatime  0  2\n\n",
            boot_uuid
        ));
    }

    // Add EFI partition
    let efi_part = layout.partitions.iter().find(|p| p.is_efi);
    if let Some(efi) = efi_part {
        let efi_device = partition_path(device, efi.number);
        let efi_uuid = get_partition_uuid(&efi_device)?;
        content.push_str(&format!(
            "# EFI System Partition\n\
             UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
            efi_uuid
        ));
    }

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!(
        "Fstab written to {} with {} encrypted volumes",
        fstab_path,
        containers.len()
    );
    Ok(())
}

/// Parameters for LVM thin fstab generation
pub struct LvmThinFstabParams<'a> {
    pub cmd: &'a CommandRunner,
    pub vg_name: &'a str,
    pub thin_volumes: &'a [ThinVolumeDef],
    pub device: &'a str,
    pub layout: &'a ComputedLayout,
    pub swap_type: &'a SwapType,
    pub boot_mapped_device: Option<&'a str>,
    pub install_root: &'a str,
}

/// Generate fstab for LVM thin provisioning layout
///
/// Creates entries for thin LVs mounted from /dev/vg/lv paths.
/// When `boot_mapped_device` is Some, the boot partition is encrypted and
/// the filesystem UUID should be read from the mapped device path.
pub fn generate_fstab_lvm_thin(params: &LvmThinFstabParams) -> Result<()> {
    let cmd = params.cmd;
    let vg_name = params.vg_name;
    let thin_volumes = params.thin_volumes;
    let device = params.device;
    let layout = params.layout;
    let swap_type = params.swap_type;
    let boot_mapped_device = params.boot_mapped_device;
    let install_root = params.install_root;
    info!("Generating /etc/fstab for LVM thin volumes");

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with LVM thin volumes:");
        for vol in thin_volumes {
            println!(
                "    /dev/{}/{} {} btrfs defaults,noatime,compress=zstd 0 {}",
                vg_name,
                vol.name,
                vol.mount_point,
                if vol.mount_point == "/" { 1 } else { 2 }
            );
        }
        return Ok(());
    }

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix - LVM Thin Provisioning layout\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n",
    );

    // Add LVM thin volume entries
    for vol in thin_volumes {
        let lv_device = lv_path(vg_name, &vol.name);
        let fs_uuid = get_partition_uuid(&lv_device)?;
        let pass = if vol.mount_point == "/" { 1 } else { 2 };

        content.push_str(&format!(
            "# {} thin volume\n\
             UUID={}  {}  btrfs  defaults,noatime,compress=zstd  0  {}\n\n",
            vol.name, fs_uuid, vol.mount_point, pass
        ));
    }

    // Add swap based on swap_type
    match swap_type {
        SwapType::Partition => {
            // Add SWAP partition if present
            let swap_part = layout.partitions.iter().find(|p| p.is_swap);
            if let Some(swap) = swap_part {
                let swap_device = partition_path(device, swap.number);
                let swap_uuid = get_partition_uuid(&swap_device)?;
                content.push_str(&format!(
                    "# Swap partition\n\
                     UUID={}  none  swap  defaults  0  0\n\n",
                    swap_uuid
                ));
            }
        }
        SwapType::FileZram => {
            // Add swap file entry
            content.push_str(&format!(
                "# Swap file (ZRAM provides additional compressed swap)\n\
                 {}  none  swap  defaults  0  0\n\n",
                SWAP_FILE_PATH
            ));
        }
        SwapType::ZramOnly => {
            // No fstab entry needed - ZRAM is configured via service
            content.push_str("# Swap: ZRAM only (configured via service)\n\n");
        }
    }

    // Add BOOT partition
    // When boot is encrypted, use the mapped device path for the filesystem UUID
    if let Some(mapped_dev) = boot_mapped_device {
        let boot_uuid = get_partition_uuid(mapped_dev)?;
        content.push_str(&format!(
            "# Boot partition (LUKS1 encrypted)\n\
             UUID={}  /boot  btrfs  defaults,noatime  0  2\n\n",
            boot_uuid
        ));
    } else {
        let boot_part = layout.partitions.iter().find(|p| p.is_boot_fs);
        if let Some(boot) = boot_part {
            let boot_device = partition_path(device, boot.number);
            let boot_uuid = get_partition_uuid(&boot_device)?;
            content.push_str(&format!(
                "# Boot partition\n\
                 UUID={}  /boot  btrfs  defaults,noatime  0  2\n\n",
                boot_uuid
            ));
        }
    }

    // Add EFI partition
    let efi_part = layout.partitions.iter().find(|p| p.is_efi);
    if let Some(efi) = efi_part {
        let efi_device = partition_path(device, efi.number);
        let efi_uuid = get_partition_uuid(&efi_device)?;
        content.push_str(&format!(
            "# EFI System Partition\n\
             UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
            efi_uuid
        ));
    }

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!(
        "Fstab written to {} with {} LVM thin volumes",
        fstab_path,
        thin_volumes.len()
    );
    Ok(())
}

/// Add swap file entry to an existing fstab
pub fn append_swap_file_entry(install_root: &str) -> Result<()> {
    let fstab_path = format!("{}/etc/fstab", install_root);

    let mut content = fs::read_to_string(&fstab_path).unwrap_or_default();
    content.push_str("\n# Swap file\n");
    content.push_str(&swap_file_fstab_entry());

    fs::write(&fstab_path, content)?;
    info!("Added swap file entry to fstab");
    Ok(())
}
