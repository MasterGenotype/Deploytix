//! Fstab generation

use crate::configure::encryption::LuksContainer;
use crate::disk::detection::partition_path;
use crate::disk::formatting::get_partition_uuid;
use crate::disk::layouts::{ComputedLayout, SubvolumeDef};
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use std::io::Write;
use tracing::info;

/// Generate fstab using UUIDs
pub fn generate_fstab(
    cmd: &CommandRunner,
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    info!("Generating /etc/fstab for {} partitions on {}", layout.partitions.len(), device);

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with entries:");
        for part in &layout.partitions {
            if let Some(ref mp) = part.mount_point {
                println!("    UUID=<uuid> {} <fstype> defaults 0 1", mp);
            } else if part.is_swap {
                println!("    UUID=<uuid> none swap defaults 0 0");
            }
        }
        return Ok(());
    }

    let mut fstab_content = String::new();
    fstab_content.push_str("# /etc/fstab: static file system information.\n");
    fstab_content.push_str("# Generated by Deploytix\n");
    fstab_content.push_str("#\n");
    fstab_content.push_str("# <file system> <mount point> <type> <options> <dump> <pass>\n\n");

    for part in &layout.partitions {
        let part_path = partition_path(device, part.number);
        let uuid = get_partition_uuid(&part_path)?;

        if part.is_swap {
            fstab_content.push_str(&format!(
                "UUID={}\tnone\tswap\tdefaults\t0\t0\n",
                uuid
            ));
        } else if let Some(ref mount_point) = part.mount_point {
            // Determine filesystem type and options
            let (fstype, options, pass) = if part.is_efi {
                ("vfat", "defaults,noatime", 2)
            } else if mount_point == "/" {
                ("btrfs", "defaults,noatime,compress=zstd", 1)
            } else {
                ("btrfs", "defaults,noatime,compress=zstd", 2)
            };

            fstab_content.push_str(&format!(
                "UUID={}\t{}\t{}\t{}\t0\t{}\n",
                uuid, mount_point, fstype, options, pass
            ));
        }
    }

    // Write fstab
    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    let mut file = fs::File::create(&fstab_path)?;
    file.write_all(fstab_content.as_bytes())?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Use fstabgen to generate fstab (alternative method)
#[allow(dead_code)]
pub fn generate_fstab_with_fstabgen(
    cmd: &CommandRunner,
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab using fstabgen");

    let output = cmd.run_output("fstabgen", &["-U", install_root])?;

    if let Some(content) = output {
        let fstab_path = format!("{}/etc/fstab", install_root);
        if !cmd.is_dry_run() {
            fs::create_dir_all(format!("{}/etc", install_root))?;
            fs::write(&fstab_path, content)?;
        }
    }

    Ok(())
}

/// Generate fstab for CryptoSubvolume layout (legacy btrfs subvolumes on LUKS)
#[allow(dead_code)]
pub fn generate_fstab_crypto_subvolume(
    cmd: &CommandRunner,
    mapped_device: &str,
    boot_device: &str,
    efi_device: &str,
    subvolumes: &[SubvolumeDef],
    install_root: &str,
) -> Result<()> {
    info!("Generating /etc/fstab for {} encrypted btrfs subvolumes", subvolumes.len());

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with btrfs subvolumes:");
        for sv in subvolumes {
            println!("    UUID=<BTRFS_UUID> {} btrfs subvol={},... 0 {}",
                sv.mount_point,
                sv.name,
                if sv.mount_point == "/" { 1 } else { 0 }
            );
        }
        println!("    UUID=<BOOT_UUID> /boot btrfs defaults,noatime 0 2");
        println!("    UUID=<EFI_UUID> /boot/efi vfat umask=0077,defaults 0 2");
        return Ok(());
    }

    let btrfs_uuid = get_partition_uuid(mapped_device)?;
    let boot_uuid = get_partition_uuid(boot_device)?;
    let efi_uuid = get_partition_uuid(efi_device)?;

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n\
         # Encrypted btrfs root (mapped as /dev/mapper/Crypt-Root in initramfs)\n"
    );

    // Add subvolume entries
    for sv in subvolumes {
        let pass = if sv.mount_point == "/" { 1 } else { 0 };
        content.push_str(&format!(
            "UUID={}  {}  btrfs  subvol={},{}  0  {}\n",
            btrfs_uuid,
            sv.mount_point,
            sv.name,
            sv.mount_options,
            pass,
        ));
    }

    // Add boot partition entry
    content.push_str(&format!(
        "\n# Boot partition\n\
         UUID={}  /boot  btrfs  defaults,noatime  0  2\n",
        boot_uuid
    ));

    // Add EFI entry
    content.push_str(&format!(
        "\n# EFI System Partition\n\
         UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
        efi_uuid
    ));

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Generate fstab for multi-volume encrypted system
///
/// Creates entries for separate encrypted partitions (ROOT, USR, VAR, HOME)
/// mounted from /dev/mapper/Crypt-* devices.
pub fn generate_fstab_multi_volume(
    cmd: &CommandRunner,
    containers: &[LuksContainer],
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    info!("Generating /etc/fstab for {} encrypted volumes", containers.len());

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with encrypted volumes:");
        for container in containers {
            let mp = container.mapper_name.trim_start_matches("Crypt-").to_lowercase();
            let mount_point = if mp == "root" { "/" } else { &format!("/{}", mp) };
            println!("    {} {} btrfs defaults,noatime,compress=zstd 0 {}",
                container.mapped_path,
                mount_point,
                if mount_point == "/" { 1 } else { 2 }
            );
        }
        return Ok(());
    }

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix - Multi-volume encrypted system\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n"
    );

    // Add encrypted volume entries
    for container in containers {
        let volume_name = container.mapper_name
            .trim_start_matches("Crypt-")
            .to_string();

        let mount_point = match volume_name.as_str() {
            "Root" => "/".to_string(),
            name => format!("/{}", name.to_lowercase()),
        };

        let pass = if mount_point == "/" { 1 } else { 2 };

        // Get UUID of the btrfs filesystem on the mapped device
        let fs_uuid = get_partition_uuid(&container.mapped_path)?;

        content.push_str(&format!(
            "# {} partition (LUKS encrypted)\n\
             UUID={}  {}  btrfs  defaults,noatime,compress=zstd  0  {}\n\n",
            volume_name,
            fs_uuid,
            mount_point,
            pass
        ));
    }

    // Add SWAP partition
    let swap_part = layout.partitions.iter().find(|p| p.is_swap);
    if let Some(swap) = swap_part {
        let swap_device = partition_path(device, swap.number);
        let swap_uuid = get_partition_uuid(&swap_device)?;
        content.push_str(&format!(
            "# Swap partition\n\
             UUID={}  none  swap  defaults  0  0\n\n",
            swap_uuid
        ));
    }

    // Add BOOT partition
    let boot_part = layout.partitions.iter().find(|p| p.is_boot_fs);
    if let Some(boot) = boot_part {
        let boot_device = partition_path(device, boot.number);
        let boot_uuid = get_partition_uuid(&boot_device)?;
        content.push_str(&format!(
            "# Boot partition\n\
             UUID={}  /boot  btrfs  defaults,noatime  0  2\n\n",
            boot_uuid
        ));
    }

    // Add EFI partition
    let efi_part = layout.partitions.iter().find(|p| p.is_efi);
    if let Some(efi) = efi_part {
        let efi_device = partition_path(device, efi.number);
        let efi_uuid = get_partition_uuid(&efi_device)?;
        content.push_str(&format!(
            "# EFI System Partition\n\
             UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
            efi_uuid
        ));
    }

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!("Fstab written to {} with {} encrypted volumes", fstab_path, containers.len());
    Ok(())
}
