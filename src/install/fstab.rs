//! Fstab generation

use crate::disk::detection::partition_path;
use crate::disk::formatting::get_partition_uuid;
use crate::disk::layouts::ComputedLayout;
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use std::io::Write;
use tracing::info;

/// Generate fstab using UUIDs
pub fn generate_fstab(
    cmd: &CommandRunner,
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab");

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with entries:");
        for part in &layout.partitions {
            if let Some(ref mp) = part.mount_point {
                println!("    UUID=<uuid> {} <fstype> defaults 0 1", mp);
            } else if part.is_swap {
                println!("    UUID=<uuid> none swap defaults 0 0");
            }
        }
        return Ok(());
    }

    let mut fstab_content = String::new();
    fstab_content.push_str("# /etc/fstab: static file system information.\n");
    fstab_content.push_str("# Generated by Deploytix\n");
    fstab_content.push_str("#\n");
    fstab_content.push_str("# <file system> <mount point> <type> <options> <dump> <pass>\n\n");

    for part in &layout.partitions {
        let part_path = partition_path(device, part.number);
        let uuid = get_partition_uuid(&part_path)?;

        if part.is_swap {
            fstab_content.push_str(&format!(
                "UUID={}\tnone\tswap\tdefaults\t0\t0\n",
                uuid
            ));
        } else if let Some(ref mount_point) = part.mount_point {
            // Determine filesystem type and options
            let (fstype, options, pass) = if part.is_efi {
                ("vfat", "defaults,noatime", 2)
            } else if mount_point == "/" {
                ("btrfs", "defaults,noatime,compress=zstd", 1)
            } else {
                ("btrfs", "defaults,noatime,compress=zstd", 2)
            };

            fstab_content.push_str(&format!(
                "UUID={}\t{}\t{}\t{}\t0\t{}\n",
                uuid, mount_point, fstype, options, pass
            ));
        }
    }

    // Write fstab
    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    let mut file = fs::File::create(&fstab_path)?;
    file.write_all(fstab_content.as_bytes())?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Use fstabgen to generate fstab (alternative method)
#[allow(dead_code)]
pub fn generate_fstab_with_fstabgen(
    cmd: &CommandRunner,
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab using fstabgen");

    let output = cmd.run_output("fstabgen", &["-U", install_root])?;

    if let Some(content) = output {
        let fstab_path = format!("{}/etc/fstab", install_root);
        if !cmd.is_dry_run() {
            fs::create_dir_all(format!("{}/etc", install_root))?;
            fs::write(&fstab_path, content)?;
        }
    }

    Ok(())
}
