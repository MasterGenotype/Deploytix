//! Fstab generation

use crate::disk::detection::partition_path;
use crate::disk::formatting::get_partition_uuid;
use crate::disk::layouts::{ComputedLayout, SubvolumeDef};
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use std::io::Write;
use tracing::info;

/// Generate fstab using UUIDs
pub fn generate_fstab(
    cmd: &CommandRunner,
    device: &str,
    layout: &ComputedLayout,
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab");

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with entries:");
        for part in &layout.partitions {
            if let Some(ref mp) = part.mount_point {
                println!("    UUID=<uuid> {} <fstype> defaults 0 1", mp);
            } else if part.is_swap {
                println!("    UUID=<uuid> none swap defaults 0 0");
            }
        }
        return Ok(());
    }

    let mut fstab_content = String::new();
    fstab_content.push_str("# /etc/fstab: static file system information.\n");
    fstab_content.push_str("# Generated by Deploytix\n");
    fstab_content.push_str("#\n");
    fstab_content.push_str("# <file system> <mount point> <type> <options> <dump> <pass>\n\n");

    for part in &layout.partitions {
        let part_path = partition_path(device, part.number);
        let uuid = get_partition_uuid(&part_path)?;

        if part.is_swap {
            fstab_content.push_str(&format!(
                "UUID={}\tnone\tswap\tdefaults\t0\t0\n",
                uuid
            ));
        } else if let Some(ref mount_point) = part.mount_point {
            // Determine filesystem type and options
            let (fstype, options, pass) = if part.is_efi {
                ("vfat", "defaults,noatime", 2)
            } else if mount_point == "/" {
                ("btrfs", "defaults,noatime,compress=zstd", 1)
            } else {
                ("btrfs", "defaults,noatime,compress=zstd", 2)
            };

            fstab_content.push_str(&format!(
                "UUID={}\t{}\t{}\t{}\t0\t{}\n",
                uuid, mount_point, fstype, options, pass
            ));
        }
    }

    // Write fstab
    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    let mut file = fs::File::create(&fstab_path)?;
    file.write_all(fstab_content.as_bytes())?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}

/// Use fstabgen to generate fstab (alternative method)
#[allow(dead_code)]
pub fn generate_fstab_with_fstabgen(
    cmd: &CommandRunner,
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab using fstabgen");

    let output = cmd.run_output("fstabgen", &["-U", install_root])?;

    if let Some(content) = output {
        let fstab_path = format!("{}/etc/fstab", install_root);
        if !cmd.is_dry_run() {
            fs::create_dir_all(format!("{}/etc", install_root))?;
            fs::write(&fstab_path, content)?;
        }
    }

    Ok(())
}

/// Generate fstab for CryptoSubvolume layout (btrfs subvolumes on LUKS)
pub fn generate_fstab_crypto_subvolume(
    cmd: &CommandRunner,
    mapped_device: &str,
    efi_device: &str,
    subvolumes: &[SubvolumeDef],
    install_root: &str,
) -> Result<()> {
    info!("Generating fstab for encrypted btrfs subvolumes");

    if cmd.is_dry_run() {
        println!("  [dry-run] Would generate fstab with btrfs subvolumes:");
        for sv in subvolumes {
            println!("    UUID=<BTRFS_UUID> {} btrfs subvol={},... 0 {}",
                sv.mount_point,
                sv.name,
                if sv.mount_point == "/" { 1 } else { 0 }
            );
        }
        println!("    UUID=<EFI_UUID> /boot/efi vfat umask=0077,defaults 0 2");
        return Ok(());
    }

    let btrfs_uuid = get_partition_uuid(mapped_device)?;
    let efi_uuid = get_partition_uuid(efi_device)?;

    let mut content = String::from(
        "# /etc/fstab: static file system information.\n\
         # Generated by Deploytix\n\
         #\n\
         # <file system> <mount point> <type> <options> <dump> <pass>\n\n\
         # Encrypted btrfs root (mapped as /dev/mapper/Crypt-Root in initramfs)\n"
    );

    // Add subvolume entries
    for sv in subvolumes {
        let pass = if sv.mount_point == "/" { 1 } else { 0 };
        content.push_str(&format!(
            "UUID={}  {}  btrfs  subvol={},{}  0  {}\n",
            btrfs_uuid,
            sv.mount_point,
            sv.name,
            sv.mount_options,
            pass,
        ));
    }

    // Add EFI entry
    content.push_str(&format!(
        "\n# EFI System Partition\n\
         UUID={}  /boot/efi  vfat  umask=0077,defaults  0  2\n",
        efi_uuid
    ));

    let fstab_path = format!("{}/etc/fstab", install_root);
    fs::create_dir_all(format!("{}/etc", install_root))?;
    fs::write(&fstab_path, &content)?;

    info!("Fstab written to {}", fstab_path);
    Ok(())
}
