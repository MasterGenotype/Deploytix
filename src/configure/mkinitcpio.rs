//! mkinitcpio configuration and hook construction

use crate::config::{DeploymentConfig, Filesystem, PartitionLayout};
use crate::utils::command::CommandRunner;
use crate::utils::error::Result;
use std::fs;
use tracing::info;

/// Construct the MODULES array based on configuration
pub fn construct_modules(config: &DeploymentConfig) -> Vec<String> {
    let mut modules = Vec::new();

    // Filesystem modules
    match config.disk.filesystem {
        Filesystem::Btrfs => modules.push("btrfs".to_string()),
        Filesystem::Ext4 => modules.push("ext4".to_string()),
        Filesystem::Xfs => modules.push("xfs".to_string()),
        Filesystem::F2fs => modules.push("f2fs".to_string()),
    }

    // Encryption modules
    if config.disk.encryption {
        modules.extend([
            "dm_crypt".to_string(),
            "dm_mod".to_string(),
        ]);
    }

    modules
}

/// Construct the HOOKS array based on configuration
pub fn construct_hooks(config: &DeploymentConfig) -> Vec<String> {
    let mut hooks = vec![
        "base".to_string(),
        "udev".to_string(),
        "autodetect".to_string(),
        "modconf".to_string(),
        "block".to_string(),
    ];

    // Keyboard/console hooks
    hooks.extend([
        "keyboard".to_string(),
        "keymap".to_string(),
        "consolefont".to_string(),
    ]);

    // For CryptoSubvolume layout, use custom hooks
    if config.disk.layout == PartitionLayout::CryptoSubvolume && config.disk.encryption {
        // Custom hooks handle encryption and mounting
        hooks.push("crypttab-unlock".to_string());
        hooks.push("mountcrypt".to_string());
        // Note: filesystems hook is NOT needed when using mountcrypt
        // as mountcrypt handles all mounting
    } else {
        // Standard encryption hook for other layouts
        if config.disk.encryption {
            hooks.push("encrypt".to_string());
        }

        // Filesystem-specific hooks
        if config.disk.filesystem == Filesystem::Btrfs {
            hooks.push("btrfs".to_string());
        }

        // Core hooks
        hooks.push("filesystems".to_string());
        hooks.push("fsck".to_string());

        // Separate /usr partition hook
        if config.disk.layout == PartitionLayout::Standard {
            hooks.push("usr".to_string());
        }

        // Resume hook for hibernation
        if config.system.hibernation {
            // Insert resume before filesystems
            let filesystems_idx = hooks.iter().position(|h| h == "filesystems").unwrap_or(hooks.len());
            hooks.insert(filesystems_idx, "resume".to_string());
        }
    }

    hooks
}

/// Construct BINARIES array
pub fn construct_binaries(_config: &DeploymentConfig) -> Vec<String> {
    vec!["lsblk".to_string()]
}

/// Construct FILES array
pub fn construct_files(config: &DeploymentConfig) -> Vec<String> {
    let files = Vec::new();

    // TODO: Add keyfile for encryption if needed
    // if config.disk.encryption {
    //     files.push("/crypto_keyfile.bin".to_string());
    // }
    let _ = config; // Silence unused warning until encryption is implemented

    files
}

/// Generate mkinitcpio.conf content
pub fn generate_mkinitcpio_conf(config: &DeploymentConfig) -> String {
    let modules = construct_modules(config);
    let binaries = construct_binaries(config);
    let files = construct_files(config);
    let hooks = construct_hooks(config);

    format!(
        r#"# mkinitcpio.conf - Generated by Deploytix
# See mkinitcpio(8) for details

MODULES=({})
BINARIES=({})
FILES=({})
HOOKS="{}"

# Compression
COMPRESSION="zstd"
COMPRESSION_OPTIONS=(-T0)
"#,
        modules.join(" "),
        binaries.join(" "),
        files.join(" "),
        hooks.join(" ")
    )
}

/// Configure mkinitcpio
pub fn configure_mkinitcpio(
    cmd: &CommandRunner,
    config: &DeploymentConfig,
    install_root: &str,
) -> Result<()> {
    info!("Configuring mkinitcpio");

    let mkinitcpio_conf = generate_mkinitcpio_conf(config);
    let conf_path = format!("{}/etc/mkinitcpio.conf", install_root);

    if cmd.is_dry_run() {
        println!("  [dry-run] Would write mkinitcpio.conf:");
        for line in mkinitcpio_conf.lines() {
            println!("    {}", line);
        }
        return Ok(());
    }

    // Backup original
    let backup_path = format!("{}.bak", conf_path);
    if fs::metadata(&conf_path).is_ok() {
        fs::copy(&conf_path, &backup_path)?;
    }

    // Write new config
    fs::write(&conf_path, mkinitcpio_conf)?;

    info!("mkinitcpio.conf written");
    Ok(())
}

/// Regenerate initramfs
#[allow(dead_code)]
pub fn regenerate_initramfs(cmd: &CommandRunner, install_root: &str) -> Result<()> {
    info!("Regenerating initramfs");

    cmd.run_in_chroot(install_root, "mkinitcpio -P")?;

    Ok(())
}
